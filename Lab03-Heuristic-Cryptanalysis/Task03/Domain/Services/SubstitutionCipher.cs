using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Task03.Domain.Abstractions;

namespace Task03.Domain.Services;

public sealed class SubstitutionCipher : ISubstitutionCipher
{
    /// <summary>Encrypts normalized text by substituting each character according to the provided permutation.</summary>
    /// <param name="normalizedText">The uppercase plaintext to transform.</param>
    /// <param name="alphabet">The ordered alphabet describing the plaintext mapping.</param>
    /// <param name="permutation">The substitution alphabet that will replace plaintext characters.</param>
    /// <returns>The encrypted text generated by applying the permutation.</returns>
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
    public string Encrypt(string normalizedText, string alphabet, string permutation)
    {
        return Transform(normalizedText, alphabet, permutation, true);
    }

    /// <summary>Decrypts normalized text by mapping cipher characters back through the alphabet.</summary>
    /// <param name="normalizedText">The uppercase cipher text to translate.</param>
    /// <param name="alphabet">The ordered alphabet describing plaintext characters.</param>
    /// <param name="permutation">The substitution alphabet that produced the cipher text.</param>
    /// <returns>The decrypted plaintext restored from the permutation.</returns>
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
    public string Decrypt(string normalizedText, string alphabet, string permutation)
    {
        return Transform(normalizedText, alphabet, permutation, false);
    }

    /// <summary>Transforms text between plaintext and ciphertext using dense lookup tables derived from a permutation.</summary>
    /// <param name="text">The text to transform.</param>
    /// <param name="alphabet">The plaintext alphabet ordering.</param>
    /// <param name="permutation">The permutation representing the cipher alphabet.</param>
    /// <param name="encrypt">Indicates whether to encrypt (<c>true</c>) or decrypt (<c>false</c>).</param>
    /// <returns>The transformed string produced by applying the lookup.</returns>
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
    private static string Transform(string text, string alphabet, string permutation, bool encrypt)
    {
        if (string.IsNullOrEmpty(text) || string.IsNullOrEmpty(alphabet) || string.IsNullOrEmpty(permutation))
        {
            return string.Empty;
        }

        if (alphabet.Length != permutation.Length)
        {
            throw new InvalidOperationException("Alphabet and permutation must be the same length");
        }

        var source = encrypt ? alphabet : permutation;
        var target = encrypt ? permutation : alphabet;

        var lookup = BuildLookup(source, target);

        return string.Create(text.Length, (text, lookup), static (dst, state) =>
        {
            var (srcText, map) = state;
            var src = srcText.AsSpan();

            ref var baseRef = ref MemoryMarshal.GetArrayDataReference(map.Table);
            var max = map.MaxChar;

            for (var i = 0; i < src.Length; i++)
            {
                int ch = src[i];
                if ((uint)ch > (uint)max)
                {
                    throw new InvalidOperationException("Character not found in substitution alphabet");
                }

                var mapped = Unsafe.Add(ref baseRef, ch);
                if (mapped < 0)
                {
                    throw new InvalidOperationException("Character not found in substitution alphabet");
                }

                dst[i] = (char)mapped;
            }
        });
    }

    /// <summary>Builds a dense lookup table mapping character codes from the source alphabet to the target alphabet.</summary>
    /// <param name="source">The source alphabet string to index.</param>
    /// <param name="target">The target alphabet string providing mapped characters.</param>
    /// <returns>A lookup structure with a table and maximum character value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveOptimization)]
    private static DenseLookup BuildLookup(string source, string target)
    {
        var max = 0;
        var s = source.AsSpan();
        foreach (int c in s)
        {
            if (c > max)
            {
                max = c;
            }
        }

        var table = new int[max + 1];
        Array.Fill(table, -1);

        for (var i = 0; i < s.Length; i++)
        {
            table[s[i]] = target[i];
        }

        return new DenseLookup(table, max);
    }

    /// <summary>Represents a dense mapping table from character code to mapped character.</summary>
    /// <param name="table">The lookup table storing mapped character codes.</param>
    /// <param name="maxChar">The largest character value that can be indexed.</param>
    private readonly struct DenseLookup(int[] table, int maxChar)
    {
        public readonly int[] Table = table;
        public readonly int MaxChar = maxChar;
    }
}